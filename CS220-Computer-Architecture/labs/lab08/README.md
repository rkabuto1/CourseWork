# Lab 8 Debugging X86

## Introduction

We are learning about X86 assembler code, especially the X86 assembler code generated by the gcc compiler. We have worked on learning about how to debug C code, and some of the things we can do with the GNU Debugger (GDB) at the C level. For example, we can set breakpoints at C instructions, or single step instruction by instruction, or print the value of C variables.

However, we aren't really executing C on the machine. We are executing X86 assembler code, and GDB must set breakpoints at X86 instructions. Each C instruction may translate into multiple X86 instructions, so when we single step in GDB, we are really executing **several** X86 instructions generated from a single C instruction, but stopping before we get to the first X86 instruction associated with the next line of C code.

When we print the value of a C variable, GDB needs to translate from the variable name to the X86 memory reference of the memory associated with that variable. For a local variable, X86 often refers to that variable as a negative offset from the %rbp register so that it gets read from the correct place in the current invocation record.

Today, we are going to learn how to get into the X86 level using GDB.

## Background

I am providing a simple C program in **x86Math.c** that reads the first command line value as an integer, and plugs that value as *x* in the equation: $x^2 -4x + 4$. Those of you who remember your high school algebra will recognize that as $(x-2) \times (x-2)$. I check the result by dividing by $x-2$, just to show that the quotient is also $x-2$.

The C program has sub-functions for each arithmetic function: myAdd, mySubtract, myMult, and myDivide. This is overkill from a C point of view, but gives insight into how arithmetic X86 instructions are generated from lines of C code.

## Provided to you

The lab10 repository already contains everything you need to investigate the X86 code generated from the simple C program in x86Math.c. This includes:
  
- **x86Math.c** - A C program which evaluates a simple polynomial.
- **Makefile** - A Makefile that has several explicit and implicit targets, as follows:
  - **test** - Run the x86Math program with an input of 7.
  - **x86Math** - Compile the x86Math.c file into an x86Math executable file.
  - **x86Math.s** - Compile the x86Math.c file into an annotated X86 assembler version of the code that shows the relationship between the C instructions and the X86 assembler code generated from those instructions.
  - **gdb** - Run gdb on the x86Math executable with a command line argument of "7", and specifying the gdb_cmds.txt file as a file which holds gdb commands that should be executed after the program is loaded.
  - **clean** - Remove anything that the make command created with this Makefile.
- **gdb_cmds.txt** - A set of gdb commands to be executed after the x86Math program is loaded.

## GDB at the X86 Level

Running gdb at the X86 level is pretty easy once you get the hang of it. Here are a few suggestions...

1. Here's a link to my [How to Use GDB](https://www.cs.binghamton.edu/~tbartens/HowTo/Using_gdb) notes. Start there.

2. The first thing to do is to set breakpoints at places where you want to see what is going on. You can set breakpoints using:
   -  function names and gdb will stop before executing the first X86 instruction in the first C instruction in that function,
   - line numbers in the C file and again, gdb will stop before executing the first X86 instruction in the C instruction on that line,
   - X86 Instruction Addresses using `break *address`, and gdb will stop before executing the instruction at that address.

3. Next, it's good to be able to see the values of variables in memory. We've already learned that you can use the gdb `print` command, and specify any valid C expression, including a variable name, as long as the code was compiled with the gdb option turned on.

   At the X86 level, we often want to look at registers. GDB has created special "variable" names for each register; just the register name preceded by a dollar sign. For example, to find out what is in the %eax register, just use the gdb command `print $eax`. GDB also has an `info registers` command, but it's easier just to print the register you care about.

   There are a couple of ways to look at memory. Even though it's tempting to use print with the C dereference operator, it quickly becomes quite complicated to get the expression correct. Especially because gdb doesn't know what type of value is in memory unless you cast the pointer to a type. Then you have to get the parenthesis correct for the casting as well as the dereference, and things get very ugly very quickly.

   Instead, take the time to learn how to use the gdb `x` command!

4. It's also quite useful to single step through X86 instructions. Use `stepi` and `nexti` to single step, and turn on `set disassemble-next-line on` so you can see what's about to get executed. Make sure you understand the difference between stepi and nexti so you skip over function invocations that you don't care about with nexti, but you can step into lower level functions that you are interested in using stepi.

## Doing the Lab

This is another lab where I'll be asking you to answer some questions on Gradescope. First, read through x86Math.c to understand how the code works. Then look at the gdb_cmds.txt file. It's already set up to get you started on the  lab... looking into how the myAdd function works under gdb.

Start off by opening up Gradescope to the Lab 10 assignment. There are 9 questions in that assignment. To answer those questions, you will need to start running GDB, and follow the directions below...

So start off running `make gdb`. This will:

- start gdb,
- load x86Math,
- run the "set disassemble-next-line on" command for you,
- set a breakpoint at the myAdd function,
- run to the first breakpoint,
- print first C instruction in the myAdd function (`int op1=x`),
- Because we are running with disassemble-next-line turned on, it will print the two x86 instructions that make up the first C instruction (two mov instructions)
- and open up a gdb prompt.

At the GDB prompt, perform the following instructions to get the answers to the Gradescope questions:

1. Print the value of the op1 variable.
2. Run the `nexti` gdb subcommand
3. Print the value of the op1 variable again.
4. Run the `nexti` gdb subcommand again
5. Print the value of the op1 variable a third time.
6. What `x` command would you use in gdb to print the op1 value? (Hint: Figure out how the op1 value is referenced in the x86 assembler, and use that same scheme in the address argument to an `x` command.)
7. Try the gdb `disassemble` command.
8. Try the gdb `disassemble /m` command.
9. Set a breakpoint at the X86 "add" instruction in the myAdd function.
10. Run the gdb `continue` command to continue to the add instruction. (Warning... if you go PAST the add instruction, restart by typing the gdb `run` command. This will get you back to the start of the myAdd function so you can try again.)
11. What are the values in the %edx and %eax registers before executing the add instruction?
12. Run the `nexti` gdb subcommand.
13. What are the values in the %edx and %eax registers *after* executing the add instruction?
14. Run the `nexti` gdb subcommand again so that you are just about to execute the C `return res;` instruction.
15. Notice that res, op1, and op2 occupy contiguous memory in the myAdd invocation record. Can you figure out a gdb `x` command to print all three values? (Notice that they are all 32 bit integer values, but you need to start at the *lowest* address and print three values.)

## Submitting the Project

When you have finished the Gradescope questions, submit the result and you are done.

Note that I've made this lab simple. If you get done early, take some time to get started on the bomb project. This lab is designed to provide some of the background required to finish the bomb project, so it may give you some ideas on how to get started.

## Grading Criteria

Your lab grade will be the Gradescope grade, but there will also be: -2 for every 24 hours your are late.
