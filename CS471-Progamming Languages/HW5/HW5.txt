-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Rick Kabuto
CS471
Due 11/13/25

Questions are adapted from Programming Language Pragmatics, by Michael L. Scott. Please submit written answers in a text file, with the extension .txt.  
Please zip your text file with the modified Perl program requested by question (3b). You do not need to submit code for any other questions.

The first three questions involve C#, Ruby, and Perl.  It is possible you do not have experience with all these languages. You are welcome (and expected) to 
use reference books or internet resources to figure out what you need to know about the meanings of the programs. Keep in mind that you do not need an 
incredibly in-depth knowledge or understanding of any of these languages to answer these questions adequately.
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
1) C# has sophisticated support for first-class subroutines.  It allows delegates to be instantiated from anonymous 
nested methods, and gives local variables and parameters unlimited extent when they are needed by such a delegate.  
Consider the provided C# program, test.cs.

a) What does this program print?

b) Which of a, b, c, and d, if any, are likely to be statically allocated?  Which could be stack allocated?  Which must be allocated on the heap?  Explain.
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

a) The way this program works is that d is going to get comptued from b(3) which is going to give us and return 5. Next, we create a small function
and the program is going to remember that C is 3 which is going to call that same function with the value 4. So its going to add 3 and 4 which gives us
7 as our second output 
    Thus our output is:
        5
        7
    
b) The variables that is going to be statically allocated is "a". This is because "a" belongs to the class and is never going to die in the program.
The variables 'd' is stack allocated. This is because d is the only local variable that can stay inside the method 'b' and does not outlive the call. 
'c' is the variable that must be alloacted to the heap because the function keeps using c after b ends. Finally, b is a static method, so the activation 
record is on the stack when called and the object returned with be on the heap.

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
2a) Examine and run the provided Ruby program, test.rb.  What does the output suggest about the scope of nested blocks in Ruby?

2b) Comment out line 2 of the program (that is, the "y = 2" line.)  Rerun the program.  Based on the output, can you make your claim about scoping from (a)
more precise?
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

a) The output when we run the code 'test.rb' is going to be:
        3 
        3    
    The reason we get this is because bar prints x, which is 3, and then changes y to 3, so the outer y also becomes 3. Therefore, the idea that we are 
    trying to understand here is that nessted blocks in ruby have a lexical scope which means it will see and change the same variables that were created 
    outside a block.
 
b) Yes. the result when we comment out the line "y = 2" makes it more precisie. This is because this code throws an error when we comment out the line
demonstrating that ruby blocks can only modify outer variables if that variable already exists in the outer scope before the block was created.

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
3) Run the provided Perl program, test.pl.
	a) What is the output?  What is (potentially) surprising about the output?
	b) Modify the code to create a reference to an anonymnous local subroutine and verify that it creates closures correctly.  Submit the modify code.
	c) Add the line "use diagnostics;" to the beginning of the original version of the program, and rerun the program.  Based on the explanation this will 
    give you, speculate as to how nested named subroutines are implemented in Perl 5.
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

a) The output when we run the code 'test.pl' is going to be:
        2
        2
   The reason we get this output is because when have nested functions in Perl 5, the inner function is not going to remember the variables defined in the 
   outer function. Therefore, the inner sub bar stays global and outputs 2. What makes this output suprising is that you would expect the value to print each 
   corresponding foo value which is 2 and 3. But Perl 5 does not make real closures for named subroutines inside other subroutines.

b) Completed

c) Perl 5 outputs a warning saying "Variable '$lex' will not be shared'. Perl 5 is trying to tell us that the inner function cannot use the outer variable
correclty. This is because because perl is not correctly linking the lexical variables in nested named subroutines. 

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
4) Read Dijkstra's "Go to Statement Considered Harmful" and Rubin's '"GOTO Considered Harmful" Considered Harmful',
contained in gotodebate.pdf.
    a) Summarize the positions presented in both letters. What arguments or evidence do they present to support their position?
    b) Which letter do you believe presents a stronger argument?  Justify your position.

For those who are interested, gotodebate_extended.pdf includes further letters regarding goto sent to ACM communications- you are not required to read these 
letters.
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

a) After reading the articles, Dijkstra position is that "goto" should be removed and not used in higher level languages. We discussed this as well during 
Lecture on Wednesday. But to further explain, the reason why Dijkstra believes goto should be removed is because the order of the code doesn't matches the order 
of execution which breaks the natural flow of code. Dijkstra presents this using proofs that during "while, if, case, etc." procedures, "goto"makes jumps confusing 
and causes problems. 

Rubins argument is that 'goto' is the opposite of Dijsktras and explains that 'goto' helps reduce complexity when implemented in programs. This was also 
discussed during lecture on Wednesday. Rubin says that many languages lack helpful constructs and 'goto' helps cut code lines by 20 to 25 percent. He presents 
this by showing a proof where a program finds the first all zero row in an N by N matrix. Using "Goto" was able solve this problem much faster than 
using conditional statements showing that goto has benefits in programming languages.

b) I believe that Dijkstra presents a stronger argument. The reason is because he supports his view with logical reasoning and proof. Rubin shows proof through 
very isolated examples which depends on a narrow & niche coding task. Dijkstra shows more general cases explain that unrestricted jumps damage the structure 
and reliability of programs. He also applies general programming practice and design principles. Rubin's argument on the other hand, only is valid for small 
exceptions which can be done in any case in a programming language.
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
5a) The C "and" and "or" operators short circuit.  Give an example of a C program that would give a different answer if these operators did not short circuit.  
    Explain why the answer would be different.

5b) Give an example of a C program containing some function f in which the order of evaluation of f's subroutine parameters changes the output of the program.
    Rewrite the program to still involve a call to f, but deterministically produce one output or the other.  Do not change the definition of f.
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

a) The program below presents a C example where it would output different answers if the operators did not short circuit. When y is true, example() is 
skipped so x is going to stay 0. Without short circuting, example() would still run and change x to 42, which would cause the output to be different.
        #include <stdio.h>
        int x = 0;
        int example() {
            x = 42;
            return 1;
        }
        int main() {
            int y = 1;
            if (y || example()) {
                printf("x = %d\n", x);
            }
            return 0;
        }

b) The function currelement doubles the current array element and returns it. This example shows that in C, the order of evaluating function arguments 
affects the result, so storing values before calling 'f' makes the output deterministic.
        #include <stdio.h>
        int arr[2] = {1, 2};
        int x = 0;

        int increment(void) { 
            return arr[x++]; 
        }
        int currelement(void) { 
            arr[x] *= 2; 
            return arr[x]; 
        }
        int f(int y, int z) { 
            return y + z; 
        }

        int main(void) {
            int z = currelement();  
            int y = increment();      
            printf("%d\n", f(y, z));  
            return 0;
        }

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
6) Loop unrolling is a code transformation that replicates the body of a loop and reduces the number of iterations, thereby decreasing the overhead of a loop.  
Loop unrolling is often performed by compilers, but in timing critical situations can also be done by hand. Unfortunately, if we replicate the body of a loop 
k times, we must deal with the possibility that the original number of loop iterations, n, may not be a multiple of k.

Briefly explain how Duff's device works.  In the above example, if N = 11, how many times will the loop iterate?  On each iteration, how many times will sum, 
squares, and i be modified

Consider:
    i = 0;
    do {
        sum += A[i]; squares += A[i] * A[i]; i++;
    } while (i < N)
to unroll this loop, we may write:
    i = 0; j = N / 4;
    do {
        sum += A[i]; squares += A[i] * A[i]; i++;
        sum += A[i]; squares += A[i] * A[i]; i++;
        sum += A[i]; squares += A[i] * A[i]; i++;
        sum += A[i]; squares += A[i] * A[i]; i++;    
    } while (--j > 0);
    do {
        sum += A[i]; squares += A[i] * A[i]; i++;
    } while (i < N)


In 1983, Tom Duff of LucasFilm "simplified this code" by inventing what is now known as "Duff's device":
    i = 0; j = (N + 3) / 4;
    switch ( N %4) {
        case 0: do { sum += A[i]; squares += A[i] * A[i]; i++;
        case 3:      sum += A[i]; squares += A[i] * A[i]; i++;
        case 2:      sum += A[i]; squares += A[i] * A[i]; i++;
        case 1:      sum += A[i]; squares += A[i] * A[i]; i++;    
        } while (--j > 0);
    }
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

a) The way that Duff constructed this device is by using switch statments and loop unrolling to see if the total number of elements is not a multiple of the 
unrolling factor. Once the program enters a case, it continues through the remaining cases without breaking. This lets the program run the right number of 
steps inside one short loop. Furthermore, Duffâ€™s method figures out how many groups of four items need to be processed and decides where to begin so that any 
remaining items are handled properly.

The loop executes three times. The first iteration performs three updates while the next two iterations perform four updates each giving us 3 + 4 + 4 = 11. 
So this results in a total of 11 updates, which matches the intended number of loop iterations from the code Duff created.
