# Turing Machine â€“ Binary Real Number Addition

## ğŸ“Œ Purpose

Construct a Turing machine that adds two binary real numbers. An input will be of the form:

X#Y

Where:

- `X` and `Y` are elements of `{0, 1}+.{0, 1}+`
- `X = xâ‚™xâ‚™â‚‹â‚...xâ‚xâ‚€.xâ‚‹â‚xâ‚‹â‚‚...xâ‚‹â‚–`
- `Y = yâ‚˜yâ‚˜â‚‹â‚...yâ‚yâ‚€.yâ‚‹â‚yâ‚‹â‚‚...yâ‚‹â‚—`

With:
1) X = (xâ‚™ Ã— 2â¿) + (xâ‚™â‚‹â‚ Ã— 2â¿â»Â¹) + ... + (xâ‚ Ã— 2Â¹) + (xâ‚€ Ã— 2â°) + (xâ‚‹â‚ Ã— 2â»Â¹) + ... + (xâ‚‹â‚– Ã— 2â»áµ)
2) Y = (yâ‚˜ Ã— 2áµ) + (yâ‚˜â‚‹â‚ Ã— 2áµâ»Â¹) + ... + (yâ‚ Ã— 2Â¹) + (yâ‚€ Ã— 2â°) + (yâ‚‹â‚ Ã— 2â»Â¹) + ... + (yâ‚‹â‚— Ã— 2â»Ë¡)

Your Turing machine must be a single-tape, one-way infinite, deterministic Turing machine.

## Output Format

When the Turing machine completes:

- The tape should contain `Z`, where `Z = X + Y`
- The original input `X#Y` may remain on the tape
- The read/write head must be positioned at the **leftmost symbol of `Z`**

### Formatting Rules

- No leading `0`s to the left of the decimal point unless `Z < 1`
  - Invalid: `01.0`  
  - Valid: `0.1`, `0.0`
- No trailing `0`s to the right of the decimal point unless `Z` is an integer
  - Invalid: `1.10`  
  - Valid: `1.0`, `2.0`

To handle formatting:
- To remove **trailing zeros**, move right to the end of `Z`, then move left over `0`s, replacing them with blank spaces until a `1` or a decimal is reached. If a decimal is reached, write a single `0` to its right.
- To remove **leading zeros**, move right until a `1` or decimal is seen. If a decimal is found first, move back left.

## Input Alphabet - { 0, 1, ., # }
## Tape Alphabet - { 0, 1, ., x, a, b, #, $, â£ }

## Example Input/Output
### Input 
111100101101101.01011100010001101001011#1010111010110001.0110011010110010010111
### Output
10010100000011110.11000010111110001111001


(The head will be placed at the leftmost digit of this output.)

## Constraints

- The machine must be **deterministic**, **single-tape**, **one-way infinite**
- Transitions may:
  - Move Left (L), Right (R), or Stay (S)
  - Use `~` as a wildcard match
- Transitions **must** read/write a single symbol per step
- Transitions like `({a,b,c}w; w, R)` are **not allowed**
- **Blank space to the left of the input may not be used**

## Implementation Notes

- You may use modular blocks to organize your logic
- Each block may handle sub-operations like formatting, padding, or addition
- The output must be aligned and cleaned per the rules above













