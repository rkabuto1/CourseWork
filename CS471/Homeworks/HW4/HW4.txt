-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--
Rick Kabuto
CS471
Assignment Due -  10/13/25

Directions -> Please submit written answers in a single text file, with the extension .txt. Some questions are adapted 
from Programming Language Pragmatics, by Michael L. Scott.  Scoping is covered in Chapter 3. You are encouraged to read 
Sections 3.1 to 3.5.
-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--

-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--
The pseudocode in this assignment uses "x : integer := Y" to denote declaring a variable x, and binding it 
to the value Y. 

Writing x := Y binds an existing variable x. print a, b should print the value of the variables a and b separated 
by a comma

Indicate the binding time for each of the following decisions in Prolog.  Explain your answers
-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--
Question 1) Indicate the binding time for each of the following decisions in Prolog.  Explain your answers

a) The total amount of space consumed by program code and data.
   Answer) A program's total space required for the code is going to be fixed when loaded into memory. Therefore, the 
   compiled clauses, symbols, fact and rules are going to be allocated by the system to memory. Therefore, the binding
   time would be at load time

b) The ":-" symbol.
    Answer) The symbol :- is a determined by Prologs language specification. Furthermore, the symbol is built into
    prologs grammar and semantics meaning this binding going to happen at design time

c) The name "descendant", as in the descendant relation defined in the class slides.
    Answer) Prolog is going to load rules and facts into memory when the program starts. The name descendant is 
    related to the clasues that define it. The binding time would be at compile time
    
d) The binding of X to y, when applying the rule reachable(X, Z) :- edge(X, Y), reachable(Y, Z). to the query:
    ?- reachable(y, w).
    Answer) Prolog is going to look for a rule where the head is going to match that specific goal. This goal is 
    what we are establishing in the query "?- reachable(y, w)." which is going to happen at runtime

-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--
2) Give an example of a program in a C-like pseudocode that would not work if variables were allocated statically.  
Explain your answer.  Your explanation should note a specific example computation that would go wrong if variables 
were statically allocated. You may provide your explanations as a separate written paragraph, or as comments in the code.
-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--

int example(int i)
{
    int counter = 0;
    if (i > 0) {
        counter = i + example(i - 1);
    }
    return counter;
}

Explanation) This chunck of code is going to add up the numbers i down to 1 using recursion. If the variables were static
every call is going to share the counter, causing the values to mess up each other. For example, if we ran "example(3)",
the shared counter would keep getting overwritten instead of giving us the answer 6. Overall, if these variables were
statically allocated, we would not get the correct result. 

-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--
3) Janet has written the following list manipulation library in C:

    typedef struct list_node {
        void* data;
        struct list_node* next;
    } list_node;

    list_node* insert(void* d, list_node* L) {
        list_node* t = (list_node*) malloc(sizeof(list_node));
        t->data = d;
        t->next = L;
        return t;
    }

    list_node* reverse(list_node* L) {
        list_node* rtn = 0;
        while (L) {
            rtn = insert(L->data, rtn);
            L = L->next;
        }
        return rtn;
    }

    void delete_list(list_node* L) {
        while (L) {
            list_node* t = L;
            L = L->next;
            free(t->data);
            free(t);
        }
    }
-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--
-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--
a) New team member Brad is familiar with Java, and writes the following code in the main loop of his program:

    list_node* L = 0;
    while (more_widgets()) {
        L = insert(next_widget(), L);
    }
    L = reverse(L);

After running for awhile, Brad's program always runs out of memory and crashes. What incorrect expectation does Brad have? 
What is going wrong and causing the crash?
-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--
Answer) Brads code keeps making new lists without deleting the old ones which is why we run out of memory and crash. 
In C lanuguage, you need to manually free memory you allocate. Therefore the reverse function is going to make a new list 
while still pointing to the same data. The old list gets left behind in memory unless you free it yourself.

Solution) In order to fix this, you can use the current reverse that Brad implemented but then you need to go through 
and delete only the old nodes after making the new list. Finally, you need to free the final list so you can release
all memory.
-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--
b) Janet explains the problem to Brad, and he updates his code:
    list_node* L = 0;
    while (more_widgets()) {
        L = insert(next_widget(), L);
    }
    T = reverse(L);
    delete_list(L);
    L = T;
This solves the insufficient memory problem, but unfortunately now the program seems to produce incorrect and 
strangely corrupted results.  What is wrong now?
-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--
Answer) The program is outputing strangely corrupted results because the new list is pointing to deleted memory. When 
Brad calling "delete_list(L)" in code is actually deleting both the old list and the data the new list needs. 

Solution) In order to fix this, Brad needs to adjust this code so that it only deletes the old list nodes, and not the
data as well. This is because your new generated list is still going to need to data from the previous list. Only delete
both the nodes and data when you are completely done with the final list
-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--
4) Consider the following pseudocode:
    procedure main()
        a : integer := 1
        b : integer := 2
        procedure middle()
            b : integer = a
            procedure inner()
                print a, b
                a : integer := 3
            inner()
            print a, b
        middle()
        print a, b

Consider each of the following scoping rules. Indicate if the program will have static semantic errors.  
If it will not, what will the program print?  Explain your answers
-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--
a) C style declaration rules-names must be declared before use, and the scope of a name extends from its declaration 
through the end of the current block.
    Answer) No Semantic Error -> Every varaible must be declared before it is used in C language. Thus this is going to 
    print:
        1, 1
        1, 1
        1, 2
b) C# style declaration rules- names must be declared before use, and the scope of a variable is the entire block in 
which it is declared.
    Answer) Static Semantic Error -> A variables scope is the entire block in which it was declared in C#. Therefore,
    we are going to get a definite assignment error in the "b : integer = a" part because b is already considered in 
    the scope but has not be initialized yet. 

c) Modula-3 - names can be declared in any order at any time, and there scope is the entire block in which they are 
declared.
    Answer) No Semantic Error -> Variables can be declared in in any order when using Modula-3. Furthermore, you
    are able to reference variables before their declaraotion as long as those variables are within the same block.
    Thus the resulintg output is going to print:
        1, 1
        1, 1
        1, 2

-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--
5) A common argument in favor of dynamic scoping is that it allows reuse and customization of subroutines.  Suppose we 
have a subroutine print_integer, which can print its input in a variety of basis (binary, decimal, hexadecimal, etc.)  
Usually, we want to use decimal, and so we do not want to always have to specify decimal.  Instead, we want to default 
to decimal, and, in the rare case we want hexadecimal, we will write the following code:
    
    print_base : integer := 16
    print_integer(n)

The counterargument is that there are usually other ways to achieve the same effect without dynamic scoping.  Describe 
at least two ways without dynamic typing to be able to print integers in a variety of bases, while allowing print_integer(n) 
to print n in decimal notation.
-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--
Answer Method 1) One method is that we can use an optional paramter and if there is no base provided, then we
automatically print the base 10 decimal:
    void print_integer(int x) {        
        print_base(x, 10);
    }
    void integerbase(int x, int base) {   
        print_base(x, base);
    }

Answer Method 2) Another way is by printing a number in different forms such as decimal hexadecimal or binary. If you 
dont choose a base, then we can set the default to 10. We can use case switching to decide what to print based on 
the number given.

    #define BASE_DEFAULT 10  
    void integerbase(int x, int base) {
        switch (base) {
            case 10:
                printf("%d\n", x);
                break;

            case 16:
                printf("%X\n", x);
                break;

            case 2:
                for (int i = 31; i >= 0; i--)
                    printf("%d", (x >> i) & 1);
                printf("\n");
                break;

            default:
                printf("Unsupported base: %d\n", base);
                break;
        }
    }
    void print_integer(int x) {
        integerbase(x, BASE_DEFAULT); 
    }

-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--
6) Consider the following pseudocode:
   x : integer := 9
   y : integer := 20
   procedure add()
         x := x + y
   procedure second(P : procedure)
         x : integer := 3
         P()
   procedure first()
         y : integer := 2
         second(add)

   first()
   print x
-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--

a) What does this program print if the language uses static scoping?  Briefly explain.
    Answer) When we use static scoping, the x and y are going to refer to the global variables because the program
    is going to define add in the global scope. So, our result is going to be x = 9 and y = 20 and the output being 29.

b) What does this program print if the language uses dynamic scoping with deep binding?  Briefly explain.
    Answer) If we use dynamic scoping with deep binding, then we are going to use values that existed when the function
    was passed. Therefore, add is going to use the global scope of x being 9 and then y being 2 which gives us the result
    of 11. 

c) What does this program print if the language uses dynamic scoping with shallow binding?  Briefly explain.
    Answer) If we use dynamic scoping with shallow binding, then we are going to run into a similiar scenario to part b
    but instead we are going to look for varaibles that exist at that moment the funciton is called. However, these
    changes are going to occur within the function. Since we are printing out the global scope, only the value was 
    affected locally inside second, so the result is 9
    
d) Give three concrete example programs in three different languages of your choosing in which a variable is live but 
not in scope.  Briefly explain each example.

-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--
1. Python -> This code shows that a varaible a is still active inside the returned function even after python_example()
has finished running.

def python_example():
    a = 0             
    def incrementor():
        nonlocal a  
        a += 1
        return a
    return incrementor

b = python_example()

-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--

-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--
2. Javascript - The varaible a is declared inside the function and goes out of the scope once it is finished. But the
a is going to stay live because the inner functions retains access through a closure. 

function javascript_ex() {
  let a = 0;          
  return function () { 
    a = a + 1;
    return a;
  };
}

const output = javascript_ex();
-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--

-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--
3. C++ - The varaible a is declared inside the function "Cplus_ex". Thus it goes out of the scope once that function
finishes. But when helper runs, it still accesses the live value of a through its pointer.

void helper(int *p) {
    printf("%d\n", *p);
}
void Cplus_ex() {
    int a = 42;
    helper(&a); 
}
int main() {
    Cplus_ex();
}
-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=-=-=-=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--=-=--
