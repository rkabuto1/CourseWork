-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Rick Kabuto
CS471
Homework 6
Due October 27 2025

Some questions are adapted from Programming Language Pragmatics, by Michael L. Scott.

Please submit written answers in a text file, with the extension .txt.  The solutions to (1) and (3) should be 
submitted as a separate files.
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
1) Bentley [Ben, Chapter 4] provides the following informal description of a binary search: We are to determine whether the
sorted array X[1..N] contains the element T....  Binary search solves the problem by keeping track of a range within the array 
in which T must be if it is anywhere in the array.  Initially, the range is the entire array. The range is shrunk by comparing 
its middle element to T and discarding half the range.  The process continues until T is discovered in the array or until the 
range in which it must lie is known to be empty.

Write code for binary search in an imperative programming language of your choice.  Note the name of a the language in a 
comment at the top of the file. What loop construct(s) did you find to be useful?  Why these loop constructs, and not others?

As a side note, when Bentley asked more than a hundred professional programmers to solve this problem, Bentley found that 
only about 10% got it right the first time, without testing.

[Ben] John L. Bentley.  Programming Pearls.  Addison-Wesley Professional, 2000.  First edition, 1996
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Imperative Language - Python

    def binarySearch(X, Target):
        low = 0
        high = len(X) - 1
        while low <= high:
            mid = (low + high) // 2
            if X[mid] == Target:
                return mid
            elif X[mid] < Target:
                low = mid + 1
            else:
                high = mid - 1
        return -1

Explanation) This Python code performs a binary search on a sorted list by maintaining two boundaries to define the range of 
where the target could be. The while loop is the most useful construct here because the number of iterations keep running as
long as it needs to until we find our answer. There is no fixed count which is very useful in searching algorithms. It clearly 
represents the condition to keep searching while the range is valid making the code simple and efficient.

Sources -> https://www.w3schools.com/python/python_dsa_binarysearch.asp
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
2) C++ and Java loops can be written with empty bodies by placing all side effects into the tests, such as in the following 
two examples:
    Example 1:
        int i = 0;
        while (a[i++] != 0);

    Example 2:
        int i = 0
        for (i = 0; a[i] != 0; i++);
    
Are these loops equivalent? Explain.
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Answer) No. These loops are not equivalent. This because that the the while loop is going to cause i to be incremented as part 
of the test. The variable i is going to be one more than at the position we are looking for when the loop ends. The for loop 
is going to cuase i to be incremented after the test which is going to cause the variable i to stop exactly at the position
when we reach zero. For example, if we have an arary a = [1, 0, 2], the while loop ends with index i = 2, and the for loop ends 
with index i = 1.

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
3) Consider the BinTree Python class shown below.  The code below defines a preorder traversal of a binary tree, using the 
yield keyword.

class BinTree:
    def __init__(self):
        self.data = self.lchild = self.rchild = None

    # insert, lookup, etc.
    def preorder(self):
        if self.data != None:
            yield self.data
        if self.lchild != None:
            for d in self.lchild.preorder():
                yield d
        if self.rchild != None:
            for d in self.rchild.preorder():
                yield d

a) Explain the behavior of the yield keyword. Cite any sources you use.

b) Write inorder and postorder iterators for BinTree, making use of the yield keyword.
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

a) The yield keyword in Python turns a function into a generator. Every time we run the funtion, we pause where we left off 
and continue from that position the next time that same function is called. Esentially, this going to cause that the function 
is to return one value at a time. In the code provided in the question, yield is very useful in transversals because allow the 
program to go through each node and give us a value right away instead of storing all values in a list first allowing
us to save memory.

Sources - https://www.geeksforgeeks.org/python/python-yield-keyword/
Sources - https://www.w3schools.com/python/ref_keyword_yield.asp

b)  class BinTree:
    def __init__(self):
        self.value = self.leftchild = self.rightchild = None

    def inorder(self):
        stackNodes = []
        curr = self
        while stackNodes or curr:
            if curr:
                stackNodes.append(curr)
                curr = curr.leftchild
            else:
                curr = stackNodes.pop()
                yield curr.value
                curr = curr.rightchild

    def postorder(self):
        stackNodes = [(self, False)]
        while stackNodes:
            node, explored = stackNodes.pop()
            if node is None:
                continue
            if explored:
                yield node.value
            else:
                stackNodes.append((node, True))
                if node.rightchild:
                    stackNodes.append((node.rightchild, False))
                if node.leftchild:
                    stackNodes.append((node.leftchild, False))

Sources -> https://www.geeksforgeeks.org/dsa/binary-tree-iterator-for-inorder-traversal/

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
4) Assume the "type" keyword is used to introduce a type alias.  Consider the following:

type coffee = struct { variety : string, weight : float }
type plant = struct { variety : string, weight : float }
type person = struct { name : string, height : float }

Which of these types:

coffee
plant
person
array [1..10] of coffee
array [1..10] of plant
array [1..10] of person

would a compiler likely consider to have equivalent types under
    (a) structural equivalence?
    (b) strict name equivalene?
    (c) loose name equivalence?

Briefly justify your answers.
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

a) structural equivalence
    - coffee and plant would come out to be equivalent because their fields have the same names and types which is variety and 
    weight being the same  
    - array[1..10] of coffee and array[1..10] of plant would also be equivalent since their element structures match as well.

b) strict name equivalene?
    - No types would be equal. The structures match, coffee, plant, and person are distinct. Furthermore, their corresponding
    arrays are also distinct because they depend on distinct element types.

c) loose name equivalence?
    - Coffee and plant would come out to be equal because they have identical structures. The only difference here is the 
    type name which is coffee and plant. But loose name equivalence treats types with the same layout as equal. Furthermore, 
    their arrays would also be equivalent for the same reason. 

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
5) Describe the difference between type equivalence and type compatibility.
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Answer) In some kind of programming language, Type equivalence means that two types are going to be treatead the exactly the 
same way whileType compatibility means that two types have the possiblity to work together if they are not the same. Compatibility 
often allows implicit conversions, while equivalence requires the types to match exactly. 

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
6) What is type inference?  Explain three contexts in which type inference occurs?
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Answer) Type inference is the process by which a compiler automatically determines the type of an expression without the 
programmer explicitly stating it.  This produces optimization problem though for the computer at compile time though.

The three contexts where type inference occurs:
    1. The compiler detects the variable’s type from the value assigned to it which is variable initialization
    2. The compiler detects the function’s return type based on the expressions it returns.
    3. When a functions parameter types are inferred from how the function is used, such as from the arguments passed in calls.
 

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
7) Show the type derivation for the following simply-typed lambda calculus expression (I am using "\" in place of lambda):
	(\x : int . \f : (int -> int) -> int -> int . \g : int -> int . f (f g) x) 6
As long as it is neat enough to easily read, you may submit your answer as a png or jpeg image of a handwritten derivation 
tree.
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Answer) Jpeg Inside Tar.Gzip File labeled "Question7-RickKabuto.pdf"

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
8) What is the type of n in the following ML program? What is the type of sum? Write a sentence or 2 explaining how a 
compiler would deduce your answers to this question.

let rec sum n = if n > 0 then n + sum (n - 1) else 0
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Answer) The type of n is going to be an int. We know this is an int because we see in the code that n is being compared with
0. Therefore, it has to be some sort of value/number which correlates to the type int. The compiler is going to deduce
this line of code by seeing how n is being used. The variable n is being compared to a value 0 so that means that n must be an 
int in order for that to syntactically make sense. Furthermore, the function also returns a number, which confirms that both the 
input and output are integers.