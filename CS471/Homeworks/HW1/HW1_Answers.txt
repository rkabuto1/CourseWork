Rick Kabuto Homework 1 Answers

Quesiton 1) "I have read the Course Syllabus for CS 471, Programming Languages."

Question 2) True or False: some programming languages are more "powerful" then others.  Explain your answer.
    Answer) False.  The reason that I conclude this statement as false is because any turing complete language is 
    able to compute anything that is computable. In theory, all languages are equally powerful. There is a confusion 
    behind the differences in efficiency and built in features for each of these languages and relating them to 
    be "more powerful". However, in terms of raw computational power, this is not true.
    
    Source -> B. Jack Copeland, The Church–Turing Thesis, in The Stanford Encyclopedia of Philosophy,
                edited by Edward N. Zalta (Spring 2024 Edition).

Question 3) Write regular expressions over the vocabulary { 0, 1 } for each of the following: Your answers should be 
written using the regex syntax presented in class. 

3a) All strings which, when interpreted as binary numbers, represent all non-negative numbers divisible by 4.
    Answer) (0|1)*00|0
3b) All strings consisting of two-or-more 1's followed by a non-empty sequence of 0's.
    Answer) 11(1)*0+
3c) All strings containing the substring 101, and ending in a 1.
    Answer) (0|1)*101((0|1)*1)?
3d) All strings consisting of n 0's, followed by 2n 1's (where n is an arbitrary non-negative integer.)
    Answer) This cannot be expressed as a regular expression. This is beacuse the language is not regular. 
    This can be proved through the pumping lemma which is a proof we learned how to do in CS373. 
    You can pump the number of 0s to where it is ouside of the language and contradicts the pumping lemma.

Question 4) Given the following grammar for regular expresions over the vocabulary { 0, 1 }:
    re := re re
        | re '|' re                    (Alteration)
        | re '*'
        | ( re )
        | 0
        | 1

4a) A leftmost derivation is a derivation in which the leftmost non-terminal is expanded at each step.  Show a leftmost derivation for the regex 01|1*.
    Answer) To do a left most derivation. This is how it would look
        Step 1 -> re re 
        Step 2 -> re | re 
        Step 3 -> re re | re 
        Step 4 -> 0 re | re 
        Step 5 -> 0 1 | re 
        Step 6 -> 0 1 | re *
        Step 7 -> 0 1 | 1 * 
        Step 8 -> 01|1* 

4b) Show that the grammar is ambiguous.
    Answer) A grammar being ambigious means that an input string can be parsed in more than one way. Which is 
    what we learned in lecture slides set 2 & 3. Here is another way we parse this into 01|1*
        Step 1 -> re 
        Step 2 -> re re 
        Step 3 -> 0 re
        Step 4 -> 0 re | re
        Step 5 -> 0 1 | re
        Step 6 -> 0 1 | re *
        Step 7 -> 0 1 | 1 *
        Step 8 -> 01|1*

Question 5) Consider the grammar:
    expr := expr @ term
          | term
    term := A
          | B
          | C

5a) Why can this not be directly used in a recursive-descent parser?  What would go wrong if it is?
    Answer) The reason that this can not be directrly used in a recursive-descent parsre is because
    we would get an infinite loop. This is because the grammar is left recursive & if we tried to expand 
    the expr, we would not be able to get to A, B or C.

5b) Suppose your friend suggested rewriting the production rule as: expr := term @ expr. To avoid the problem you identified in (a).  
Is this a satisfactory way of converting the grammar for use in a recursive-descent parser? Explain your answer.
    Answer) No, if we rewrote the production rule as expr: term @ expr, we would still encouters problems 
    with this. Since we stated previously that the original grammar is left associative, then the associativity
    for the @ would result in two different answers. For example, (A @ B) @ C would be the result of the 
    first grammar while A @ (B @ C) would be the result for the second grammar if we flipped the production rule.
    There was a similiar problem & solution that was described in lecture slideshow 3.

    Sources - Lecture Slides 2, 3 & 4 From CS471. 


Question 6) Provide a CFG for basic regular expressions over the vocabulary { 0, 1 } with the usual regex notation of left-associative justaposition used 
for concatenation, left-associative infix | used for alternation, and postfix unary * used for Kleene closure. The operators should have the usual 
precedence. The grammar should allow the use of parentheses in the usual fashion to override the default associativity and precedence. Your CFG should 
enforce the associativity and precedence of the operators.
    Answer) <regularexpression>   ::= <regularexpression> "|" <conctentation> | <conctentation>       
            <conctentation>       ::= <conctentation> <post> | <post>            
            <post>                ::= <result> "*" | <result>                   
            <result>              ::= "0" | "1" | "(" <regularexpression> ")"
    
    Sources - Lecture Slides 2, 3 & 4 From CS471. 


Question 7) Transform your grammar from the previous question to be suitable for recursive-descent parsing. Provide pseudo-code for a recursive-descent 
recognizer for this transformed grammar.
    Answer) <regularexpression>   ::= <conctentation> { "|" <conctentation> }        
            <conctentation>       ::= <post> { <post> }                 
            <post>                ::= <result> [ "*" ]                     
            <result>              ::= "0" | "1" | "(" <regularexpression> ")"


    PsuedoCode) 
            recognizer(input_string):
                // Convert input_string into a list of tokens, one character per token.
                // Append a special end of input marker to the list.
                // Initialize an index to zero to track the current token position.
                // Begin parsing by calling regularexpression().
                // After we finish parsing, if the next token is not end of the input, reject the input.
                // If no errors were raised and we are at end of input, accept the regex.

            peekToken():
                // Return the current token without consuming it.
                // Used to determine what rule applies next based on lookahead.

            matchToken(expected):
                // If the current token equals the expected token, consume it and advance.
                // If not, output a syntax error.

            requireToken(t):
                // Require that the next token matches t exactly.
                // If there exists a mismatch, output a syntax error.

            canStartResult(tok):
                // return true if tok can start a <result>.
                // Valid options are 0, 1, or (.
                // Used to decide whether another <post> can follow during concatenation.

            regularexpression():
                // Parse a conctentation.
                // While the next token is |, parse another conctentation.

            conctentation():
                // Require at least one post.
                // Then parse zero or more additional post elements in a loop.
                // This implements concatenation as middle precedence and left associative.

            post():
                // Parse a result first.
                // Then, if the next token is *, consume it.
                // This implements the Kleene star as highest precedence, postfix unary.

            result():
                // If the current token is 0 or 1, consume it.
                // If the current token is (, consume it, then parse a nested regularexpression().
                // Require that it ends with a matching ).
                // If none of these, output a syntax error.
        
        Sources - Lecture Slides 2, 3 & 4 From CS471. 


Quesiton 8)  Examine arith1.c: It contains an implementation of a simple arithmetic calculator. The following will compile and run a few test cases. 
The arith1 language is parsed used a recursive-descent parser: It is fairly straightforward to determine the language's grammar from the parser. 
    make arith1
    ./arith1
    1 + 2 + 3
    ./arith1 
    1 + 2 * 3

8a) Using the code, give the complete grammar in BNF form 
    Answer) <start>       ::= <expr> "\n"

            <expr>        ::= <term> <tailofexpr>
            <tailofexpr>  ::= "+" <term> <tailofexpr> | e

            <term>        ::= <factor> <tailofterm>
            <tailofterm>  ::= "*" <factor> <tailofterm> | e

            <factor>      ::= <group> | <num>
            <group>       ::= "(" <expr> ")"

            <num>         ::= <result> <digits>
            
            <digits>      ::= <result> <digits> | e
            <result>      ::= "0" | "1" | "2" | "3" | "4" |  "5" | "6" | "7" | "8" | "9"


8b) Is the grammar left or right recursive? How does that affect the associativity of plus and mult? 
    Answer) The grammar presented in 8a is not left recursive because the recurision only is presented in the tails of the
    grammar that was constructed. Thus, the grammar is RIGHT RECURSIVE because both the expr and term the nonterminals appears on the 
    righ side position in the produiction rule. However, the evulation of associtivaty of plus and mult is going to be LEFT associtatve 
    because each nonterminl computes the left operand first.

8c) Using the grammar you found in (a) add two new operators,  divide, "/",  and minus, "-" , operators to the arith1 language .  
The "-" should have the a higher precedence than "+" and lower precedence than "*".  The divide operator, "/", should have the higher 
precedence than "*" but still be able to be overridden using parentheses as defined by the grammar. Both operators should have the 
same associativity as plus and times. =Give the modified grammar. 
    Answer) <start>           ::= <expr> "\n"

            <expr>            ::= <plus>
            <plus>            ::= <difference> <tailofplus>
            <tailofplus>      ::= "+" <difference> <tailofplus> | e

            <difference>      ::= <multiplication> <tailofminus>
            <tailofminus>     ::= "-" <multiplication> <tailofminus> | e

            <multiplication>  ::= <divide> <tailoftimes>
            <tailoftimes>     ::= "*" <divide> <tailoftimes> | e

            <divide>          ::= <fac> <tailofdivide>
            <tailofdivide>    ::= "/" <fac> <tailofdivide> | e

            <fac>             ::= <group> | <num>
            <group>           ::= "(" <expr> ")"

            <num>             ::= <result> <digits>
            <digits>          ::= <result> <digits> | e
            <result>          ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"


8d) Modify arith1.c and add the new operator that you defined in (c). Pay careful attention to the pattern between the original grammar 
and the associated function calls in arith1.c. If you have properly adjusted the grammar, it should be a straightforward modification of 
the original functions with the additional of a couple new function for the new operator.  Divide should round toward 0. You should pay 
careful attention to how expressions evaluate; a compile and a correct evaluation of some expressions does not mean you have modified 
everything correctly. Try the sample cases below.  
        ./arith1 
        1 + 2 - 2 
        The result is: 1
        ./arith1
        2 - 3 * 5
        The result is: -13
        ./arith1 
        5 / 2
        The result is: 2
        ./arith1 
        10 - 7 - 2
        The result is:   5
        ./arith1 
        10 - 5 / 2
        The result is:   8

Sources for Questions 8a, 8b, 8c, 8d. 
    - Chu, I. (n.d.). BNF and EBNF. In CSC 447 Lecture Notes Week 3 (pp. 1–22). DePaul University. Retrieved August 30, 2025, 
        from https://condor.depaul.edu/ichu/csc447/notes/wk3/BNF.pdf
    - Zeller, A., Gopinath, R., Böhme, M., Fraser, G., & Holler, C. (n.d.). Fuzzing with Grammars. In The Fuzzing Book. 
        Retrieved August 30, 2025, from https://www.fuzzingbook.org/html/Grammars.html  fuzzingbook.org +14
    - GeeksforGeeks. (2021, July 20). BNF notation in compiler design. Retrieved August 30, 2025, from GeeksforGeeks website 

Question 9) Examine arith2.c: It contains another implementation of a simple arithmetic calculator. The following will compile and 
run a few test cases.  The arith2 language is parsed using a slightly different technique, although it is still considered a recursive-descent 
parser. Pay careful attention to the way while loops are used to parse, instead of pure recursion. Thinking in terms of EBNF (hint: kleene star) 
may help determine the difference from the previous grammar.

    make arith2 
    ./arith2 
    1 + 2 * 3 
    ./arith2 
    1 + 2 + 3

9a) Using the code, give the complete grammar in BNF or EBNF form 
    Answer) <start>       ::= <expr> "\n"

            <expr>        ::= <term> <tailofexpr>
            <tailofexpr>  ::= "+" <term> <tailofexpr> | e

            <term>        ::= <fac> <tailofterm>
            <tailofterm>  ::= "*" <fac> <tailofterm> | e

            <fac>         ::= <group> | <num>
            <group>       ::= "(" <expr> ")"

            <num>         ::= <result> <digits>
            <digits>      ::= <result> <digits> | e

            <result>       ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"


9b) Is the grammar left or right recursive? How does that affect the associativity of plus and mult? 
    Answer) Based on the grammar that was constructed from 9a, the grammar is right recursive. This is because the nonterminal
    tails <tailofexpr> expands as + <term> <tailofexpr> and the same story for <tailofterm>. Furthermore, this grammar shows that 
    the parser computes the first operand, then iterates in a loop and folds in each subsequent operand. This means the evaulation 
    goes from left to right and that the multiplcation and plus are left associatiatve. Thus for example, we would get 1 + 2 + 3 
    as (1 + 2) + 3

9c) Using the grammar you found in (a) add two new operators,  divide, "/",  and minus, "-" , operators to the arith2 language .  
The "-" should have the a higher precedence than "+" and lower precedence than "*".  The divide operator, "/", should have the higher 
precedence than "*" but still be able to be overridden using parentheses as defined by the grammar. Both operators should have the 
same associativity as plus and times. =Give the modified grammar. 
    Answer) <start>       ::= <expr> "\n"

            <expr>        ::= <sum>
            <sum>         ::= <minus> <tailofsum>
            <tailofsum>   ::= "+" <minus> <tailofsum> | e

            <minus>       ::= <times> <tailofminus>
            <tailofminus> ::= "-" <times> <tailofminus> | e

            <times>       ::= <divide> <tailoftimes>
            <tailoftimes> ::= "*" <divide> <tailoftimes> | e

            <divide>      ::= <fac> <tailofdivide>
            <tailofdivide>::= "/" <fac> <tailofdivide> | e

            <fac>         ::= <group> | <num>
            <group>       ::= "(" <expr> ")"

            <num>         ::= <result> <digits>
            <digits>      ::= <result> <digits> | e
            <result>      ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

9d)  Modify arith2.c and add the new operator that you defined in (c). Pay careful attention to the pattern between the original grammar 
and the associated function calls in arith1.c. If you have properly adjusted the grammar, it should be a straightforward modification of 
the original functions with the additional of a couple new function for the new operator.  Divide should round toward 0. You should pay 
careful attention to how expressions evaluate; a compile and a correct evaluation of some expressions does not mean you have modified 
everything correctly. Try the sample cases below.  

    Try the sample cases below. 

    ./arith 
    1 + 2 - 2 
    The result is: 
    1 

    ./arith 
    2 - 3 * 5
    The result is: -13

    ./arith 
    10 - 5 / 2
    The result is:
    8

    ./arith 
    10 - 7 - 2
    The result is:
    1

Sources for Questions 9a, 9b, 9c, 9d. 
    - Chu, I. (n.d.). BNF and EBNF. In CSC 447 Lecture Notes Week 3 (pp. 1–22). DePaul University. Retrieved August 30, 2025, 
        from https://condor.depaul.edu/ichu/csc447/notes/wk3/BNF.pdf
    - Zeller, A., Gopinath, R., Böhme, M., Fraser, G., & Holler, C. (n.d.). Fuzzing with Grammars. In The Fuzzing Book. 
        Retrieved August 30, 2025, from https://www.fuzzingbook.org/html/Grammars.html  fuzzingbook.org +14
    - GeeksforGeeks. (2021, July 20). BNF notation in compiler design. Retrieved August 30, 2025, from GeeksforGeeks website 